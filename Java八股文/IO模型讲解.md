# I/O

## 何为I/O？

<font size = 4>I/O（Input/Output） 即为输入/输出。</font>

<font size = 4>我们先从计算机结构的角度来解释一下I/O。</font>

根据冯·诺依曼结构，计算机结构分为5大部分：运算器、控制器、存储器、输入设备、输出设备。
![[Pasted image 20220430225852.png]]
输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既属于输入设备，也属于输出设备。

输入设备向计算机输入数据，输出设备接收计算机输出的数据。

从计算机结构的视角来看的话，I/O描述了计算机系统与外部设备之间通信的过程。

我们再从应用程序的角度来解读下I/O。

根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性的安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space）。

像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行IO操作，一定是要依赖内核空间的能力。

并且，用户空间的程序不能直接访问内核空间。

当想要执行IO操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。

因此，用户进程想要执行IO操作的话，必须通过 `系统调用` 来间接访问内核空间。

我们在平常开发过程中接触最多的就是 `磁盘IO（读写文件）` 和 `网络IO（网络请求和响应）`。

<font size = 4>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起IO调用（系统调用），操作系统负责的内核执行具体的IO操作。也就是说，我们的应用程序实际上只是发起了IO操作的调用而已，具体IO的执行是由操作系统的内核来完成的。</font>


当应用程序发起I/O调用后，会经历两个步骤：
1、内核等待I/O设备准备好数据
2、内核将数据从内核空间拷贝到用户空间。

## 有哪些常见的IO模型？
UNIX系统下，IO模型一共有5种：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O和异步I/O。

这也是我们经常提到的5种IO模型。

# Java中3种常见IO模型
## BOI（Blocking I/O）
<font size = 4>`BIO`属于同步阻塞IO模型。</font>

同步阻塞IO模型中，应用程序发起read调用，会一直阻塞，直到内核把数据拷贝到用户空间。

![[Pasted image 20220501165751.png]]

在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，我们需要一种更高效的I/O处理模型来应对更高的并发量。

## NIO（Non-blocking/New I/O）
Java中的NIO于Java 1.4中引入，对应 `java.nio`包，提供了`Channel`, `Selector`, `Buffer`等抽象。NIO中的N可以理解为 Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。对于高负载、高并发的（网络）应用，应使用NIO。

Java中的NIO可以看作是 `I/O多路复用模型`。也有很多人认为，Java中的NIO属于同步非阻塞IO模型。

我们先来看看 `同步非阻塞IO模型`。

![[Pasted image 20220501190447.png]]

同步非阻塞IO模型中，应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

相比于同步阻塞IO模型，同步非阻塞IO模型确实有了很大改进。通过轮询操作，避免了一只阻塞。

但是，这种IO模型同样也存在问题：`应用程序不断进行I/O系统调用轮询数据是否已经准备好的过程是十分消耗CPU资源的`。

这个时候，`I/O多路复用模型`就上场了。

![[Pasted image 20220501190852.png]]

I/O多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核数据准备好了，用户县城再发起read调用。read线程调用的过程（数据从内核空间 -〉用户空间）还是阻塞的。

> 目前支持IO多路复用的系统调用，有select，epoll等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
> + **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> +  **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

<font size = 4>IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。</font>

Java中的NIO，有一个非常重要的选择器（Selector）的概念，也可以被称为 `多路复用器`。通过它，只需要一个线程便可以管理多个客户端。当客户端数据到了之后，才会为其服务。

![[Pasted image 20220501193200.png]]

## AIO（Asynchronous I/O）
AIO 也就是 NIO 2。Java 7中引入NIO的引进版 NIO 2.他是异步IO模型。

异步IO是基于时间和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

![[Pasted image 20220501193735.png]]

目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试过AIO，不过又放弃了。这是因为，Netty使用了 AIO 之后，在Linux系统上的性能并没有多少提升。

最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。

![[Pasted image 20220501194058.png]]